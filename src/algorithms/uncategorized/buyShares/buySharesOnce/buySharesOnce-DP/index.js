/**
 * 买卖股票问题：只能交易一次，动态规划解法
 * 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
 * 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
 * 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
 *
 * 举例：
 * 输入：prices = [7, 1, 5, 3, 6, 4]
 * 输出：5
 */

const bySharesOnce = (prices) => {
  // 我们设定动态规划数组，dp数组的内容值表示当前获利情况
  // dp数组维度说明，数组第一个维度表示买入或者不买入股票，第二个维度表示天数，例如：
  // dp[0] 表示不买入，dp[1] 表示买入
  // dp[0][0] 表示第一天不买入的价值，dp[1][1]表示第二天买入的价值
  const dp = Array(2).fill(null).map(() => Array(prices.length).fill(0));
  /**
   * 我们在同一天只可能发生 买入｜不操作｜卖出 三种操作：
   * 当我们在今天买入的时候意味着 dp[1][n] = -prices[n]，并且由于题目限制该行为只能存在一次
   * 当我们今天不进行操作的时候，无论之前是否持股手中价值都保持一致，之前不持股：dp[0][n] = dp[0][n-1]，之前持股：dp[1][n] = dp[1][n-1]
   * 当我们今天卖出的时候，今天变为不买入状态，dp[0][n] = dp[1][n-1] + prices[n]
   *
   * 所以我们能够获取的最大价值可以从这几种状态中获得
   */
  // 我们给dp数组一个初始值，表示第一天操作的两种状态：
  dp[0][0] = 0;
  dp[1][0] = -prices[0];
  // 我们让 max = 0是因为在第一天我们不买入一定比买入收益大，所以max初始化为0，也可以初始化为 max = dp[0][0]
  let max = 0;
  // 我们从第二天开始判断
  for (let i = 1; i < prices.length; i++) {
    // 判断我们之前买入且今天卖出收益大，还是之前持股今天不操作收益大
    dp[0][i] = Math.max(dp[1][i - 1] + prices[i], dp[0][i - 1]);
    // 判断我们今天买入亏的少，还是之前持股今天不操作亏的少
    dp[1][i] = Math.max(-prices[i], dp[1][i - 1]);
    // 最大值就是从今天的两种操作中获取价值最高的一项
    max = Math.max(dp[0][i], dp[1][i], max);
  }

  return max;
};

export default bySharesOnce;
