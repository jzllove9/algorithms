/**
 * 买卖股票问题：不限制交易次数，动态规划解法
 * 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
 * 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
 * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 *
 * 举例：
 * 输入：prices = [7, 1, 5, 3, 6, 4]
 * 输出：7
 */

const buySharesUnlimited = (prices) => {
  // 我们设定动态规划数组，dp数组的内容值表示当前获利情况
  // dp数组维度说明，数组第一个维度表示买入或者不买入股票，第二个维度表示天数，例如：
  // dp[0] 表示不买入，dp[1] 表示买入
  // dp[0][0] 表示第一天不买入的价值，dp[1][1]表示第二天买入的价值
  const dp = Array(2).fill(null).map(() => Array(prices.length).fill(0));
  /**
     * 我们在同一天只可能发生 买入｜不操作｜卖出 三种操作：
     * 当我们在今天买入的时候意味着要从之前的利润中减去今天购买的成本 dp[1][n] = dp[0][n-1] - prices[n]，
     * 当我们今天不进行操作的时候，无论之前是否持股手中价值都保持一致，之前不持股：dp[0][n] = dp[0][n-1]，之前持股：dp[1][n] = dp[1][n-1]
     * 当我们今天卖出的时候，今天变为不买入状态，dp[0][n] = dp[1][n-1] + prices[n]
     *
     * 所以我们能够获取的最大价值可以从这几种状态中获得
     */
  // 我们给dp数组一个初始值，表示第一天操作的两种状态：
  dp[0][0] = 0;
  dp[1][0] = -prices[0];
  // 我们让 max = 0是因为在第一天我们不买入一定比买入收益大，所以max初始化为0，也可以初始化为 max = dp[0][0]
  let max = 0;
  // 我们从第二天开始判断
  for (let i = 1; i < prices.length; i++) {
    // 判断我们之前持股且今天卖出收益大，还是今天不操作收益大
    dp[0][i] = Math.max(dp[1][i - 1] + prices[i], dp[0][i - 1]);
    // 判断我们在之前的最大利润上进行买入亏的少，还是之前持股今天不操作亏的少
    dp[1][i] = Math.max(dp[0][i - 1] - prices[i], dp[1][i - 1]);

    // 最大值就是从今天的两种操作中获取价值最高的一项
    max = Math.max(dp[0][i], dp[1][i], max);
  }

  return max;
};

export default buySharesUnlimited;
